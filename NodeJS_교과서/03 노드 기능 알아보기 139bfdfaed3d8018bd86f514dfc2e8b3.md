# 03. 노드 기능 알아보기
## 3.1 REPL 사용하기

자바스크립트는 스크립트 언어이므로 컴파일 없이 사용할 수 있다.

브라우저 콘솔창 말고 노드에서 제공하는 콘솔을 사용할 수 있다.

```bash
$ node
>

# .exit을 하면 종료할 수 있음
```

코드를 읽고(React), 해석하고(Eval), 결과물을 반환하고(Print), 종료할 때까지 반복(Loop)한다.

⇒ REPL

## 3.2 JS 파일 실행하기

이번엔 파일을 이용해서 실행해본다.

```bash
$ node [filePath]
```

## 3.3 모듈 만들기

모듈이란?

- 특정한 기능을 하는 함ㅁ수나 변수들의 집합

노드에서 모듈은 두 가지 형식이 존재한다.

- CommonJS Module
- ECMASCript Module

### CommonJS Module

표준이 나오기 전부터 사용해서 가장 많이 사용되는 모듈

var.js

```jsx
const a = 10
const b = 20

module.exports = {
	a,
	b
}

// 위와 동일한 방식임
// exports.a = a
// exports.b = b
// module.exports와 modules는 동일한 객체를 참조하기 때문
// 둘은 참조 관계가 깨질 수 있기 때문에 같이 안 쓰는 것이 좋음
```

func.js

```jsx
const sumResult = (a, b) => {
	console.log(`${a} + ${b} = ${a + b}`)
}

module.exports = sumResult
```

index.js

```jsx
const { a, b } = require('./var')
const sumResult = require('./func')
```

### node의 this

```jsx
console.log(this) // {}
console.log(this === module.exports) // true
console.log(this === exports); // true

(function() {
	console.log(this === exports) // false
	console.log(this === global) // true
})()
```

최상위 스코프 this는 `module.exports(exports)` 객체를 가리키며 함수 선언문 내부 this는 `global`을 가리킨다.

### require

require 함수에 대해 알아본다.

<aside>
ℹ️

자바스크립트의 함수는 객체이다. require 객체의 프로퍼티를 몇몇 알아본다.

</aside>

```jsx

```

주의 사항

dep1.js

```jsx
const dep2 = require('./dep2')
console.log('require dep2', dep2)
module.expors = () => {
	console.log('dep2', dep2)
}
```

dep2.js

```jsx
const dep1 = require('./dep1')
console.log('require dep1', dep1)
module.expors = () => {
	console.log('dep1', dep1K)
}
```

index.js

```jsx
const dep1 = require('./dep1')
const dep2 = require('./dep2')

dep1()
dep2()
```

dep2 [Function (anonymous)]
dep1 {}
(node:63506) Warning: Accessing non-existent property 'Symbol(nodejs.util.inspect.custom)' of module exports inside circular dependency
(Use `node --trace-warnings ...` to show where the warning was created)
(node:63506) Warning: Accessing non-existent property 'constructor' of module exports inside circular dependency
(node:63506) Warning: Accessing non-existent property 'Symbol(Symbol.toStringTag)' of module exports inside circular dependency

dep1의 module.exports가 함수가 아닌 빈 객체로 표시되는 것을 순환 참조라고 한다.

순환 참조가 있을 경우 순환 참조 대상을 빈 객체로 바꾸고 경고를 일으킨다.

### ECMAScript Module

- 공식적인 자바스크립트 모듈 형식으로 브라우저에서도 사용할 수 있음

require → import

exports → export

module.exports → export default

ECMAScript 모듈을 사용하기 위해서는 `.mjs`로 확장자를 사용해야 하며 `.js`를 사용하고 싶다면 package.json에서 `type: “module”` 속성을 넣으면 된다.

### __filename, __dirname

```jsx
console.log(__filename) // 현재 파일명
console.log(__dirname) // 현재 파일 경로
```

ES 모듈에서는 사용할 수 없으며 import.meta.url로 경로를 가져올 수 있다.

```jsx
console.log(import.meta.url)
```

## 3. 4 노드 내장 객체 알아보기

브라우저의 window 객체와 유사하게 Node에서 따로 내장 객체를 제공한다.

노드 프로그래밍에서 많이 사용되는 내장 객체에 대해 알아보자.

### global

> 전역 객체
⇒ 모든 파일에서 접근할 수 있음
> 

[`window.open](http://window.open) ⇒ open` 이렇게 사용할 수 있듯이 `global`을 생략해서 사용할 수 있다.

`require` 함수도 마찬가지로 `global.require` 이렇게 사용할 수 있는거임.

<aside>
ℹ️

노드에는 DOM과 BOM이 없기 때문에 window나 document 객체를 노드에서 사용할 수 없다.

따라서, 이 둘을 아우르는 globalThis 객체가 만들어졌으며 브라우저에서는 window로 노드에서는 global로 된다.

</aside>

전역 객체이기 때문에 간단한 데이터를 공유할 때 사용하기도 함

a.js

```jsx
module.exports = () => glbal.message
```

b.js

```jsx
const A = require('./a')

global.message = 'hello'

console.log(A()) // hello
```

하지만, 유지보수가 어려워져 `global` 객체를 남용하는 것은 좋지 않다.

### console

밑의 메서드들 간단히 살펴보면 좋다

- log
- time, timeEnd
- error
- table
- dir
- trace

### 타이머

- setTimeout
- setInterval
- setImmediate

⇒ 위의 함수들은 id를 반환하는데

- clearTimeout
- clearInterval
- clearImmediate

⇒ 위 함수를 통해 취소할 수 있다.

타이머를 프로미스 방식으로 사용할 수도 있는데 이는 내장 객체가 아닌 내장 모듈이다.

```jsx
import { setTimeout } from 'timer/promises'

await setTimeout(3000)
console.log('3초 뒤 실행')
```

## 3.5 노드 내장 모듈 사용하기

노드는 웹 브라우저에서 사용되는 자바스크립트보다 더 많은 기능들을 제공한다.

- 운영체제 접근
- 클라이언트가 요청한 주소
- etc

다양한 기능들 중 중요한 몇가지에 대해 알아본다.

### os

```jsx
const os = require('os')

const printMethod = (list) => {
  for (const method of list) {
    console.log(`os.${method} : ${os[method]}`)
  }
}

console.log('운영체제 정보')
printMethod(['arch', 'platform', 'type', 'uptime', 'hostname', 'release'])

console.log('경로')
printMethod(['homedir', 'tempdir'])

console.log('cpu 정보')
printMethod(['cpus'])

console.log('메모리 정보')
printMethod(['freemem', 'totalmem'])
```

```jsx
운영체제 정보
os.arch : arm64 // 아키텍처 정보 (process.arch와 동일)
os.platform : darwin // 플랫폼 정보 (process.platform과 동일)
os.type : Darwin // 운영체제 정보
os.uptime : 1351487 // 부팅 후 흐른 시간 (초) / (process.uptime은 node의 실행 시간)
os.hostname : tengui-MacBookAir.local // 컴퓨터의 이름
os.release : 24.0.0 // 운영체제 버전
경로 
os.homedir : /Users/teng // 홈 디렉토리 경로
os.tempdir : /var/folders/yk/px23h3t50fn50y19rbdwp81r0000gn/T // 임시 파일 저장 경로
cpu 정보
// 컴퓨터 코어 정보
[
  {
    model: 'Apple M1',
    speed: 2400,
    times: {
      user: 130112060,
      nice: 0,
      sys: 104499610,
      idle: 411272250,
      irq: 0
    }
  },
  {
    model: 'Apple M1',
    speed: 2400,
    times: {
      user: 123665770,
      nice: 0,
      sys: 96852340,
      idle: 425854040,
      irq: 0
    }
  },
  {
    model: 'Apple M1',
    speed: 2400,
    times: {
      user: 110993400,
      nice: 0,
      sys: 85193050,
      idle: 450975980,
      irq: 0
    }
  },
  {
    model: 'Apple M1',
    speed: 2400,
    times: {
      user: 103592020,
      nice: 0,
      sys: 77255080,
      idle: 466905420,
      irq: 0
    }
  },
  {
    model: 'Apple M1',
    speed: 2400,
    times: { user: 77763760, nice: 0, sys: 62668660, idle: 508372370, irq: 0 }
  },
  {
    model: 'Apple M1',
    speed: 2400,
    times: { user: 55906100, nice: 0, sys: 40941820, idle: 552520490, irq: 0 }
  },
  {
    model: 'Apple M1',
    speed: 2400,
    times: { user: 38153790, nice: 0, sys: 27835390, idle: 583821820, irq: 0 }
  },
  {
    model: 'Apple M1',
    speed: 2400,
    times: { user: 30141110, nice: 0, sys: 23450930, idle: 596477870, irq: 0 }
  }
]
메모리 정보
os.freemem : 63766528 // 사용 가능한 메모리
os.totalmem : 8589934592 // 전체 메모리 용량
```

### path

```jsx
const path = require('path')
const filename = __filename

// 경로 구분자 윈도우 -> '\' POISX -> '/'
console.log(`path.sep: ${path.sep}`)
// path.sep: /

// 환경 변수의 구분자
// process.env.PATH를 하면 여러 개의 경로가 구분자로 되어있는데
// 윈도우 -> ';', POSIX -> ':'
console.log(`path.delimiter: ${path.delimiter}`)
// path.delimiter: :

console.log('\n')
// 파일이 위치한 경로를 보여줌
console.log(`path.dirname(): ${path.dirname(filename)}`)
// path.dirname(): /Users/teng/archive/NodeJS_교과서/example/inner_module

// 파일의 확장자를 보여줌
console.log(`path.extname(): ${path.extname(filename)}`)
// path.extname(): .js

// 파일의 이름(확장자 포함)을 표시함 그리고 확장자를 빼고 싶다면 두 번째 인수로 확장자를 넣으면 됨
console.log(`path.basename(): ${path.basename(filename)}`)
// path.basename(): path.js
console.log(`path.basename - extname: ${path.basename(filename, path.extname(filename))}`)
// path.basename - extname: path

console.log('\n')
// 파일 경로를 root, dir, base, ext, name으로 파싱함
console.log(path.parse(filename))
/* 
{
  root: '/',
  dir: '/Users/teng/archive/NodeJS_교과서/example/inner_module',
  base: 'path.js',
  ext: '.js',
  name: 'path'
}
*/

// path.parse한 객체를 파일 경로로 합침
console.log(`path.format(): ${path.format({
  root: '/',
  dir: '/Users/teng/archive/NodeJS_교과서/example/inner_module',
  base: 'path2.js',
  ext: '.js',
  name: 'path2'
})}`)
// path.format(): /Users/teng/archive/NodeJS_교과서/example/inner_module/path2.js

// /나 \를  실수로 여러 번 사용했거나 혼용했을 때 정상적인 경로로 반환
console.log(`path.normalize(): ${path.normalize('//////////path.js')}`)
// path.normalize(): /path.js

console.log('\n')

// 파일의 경로가 상대 경로인지 절대 경로인지 판단해줌
console.log(`path.isAbsolute(/Users): ${path.isAbsolute('/Users')}`) // true
console.log(`path.isAbsolute(./home): ${path.isAbsolute('./home')}`) // false

console.log('\n')

// path.relative(기준경로, 비교경로) 기준경로에서 비교경로로 가는 방법을 알려줌
console.log(`path.relative(): ${path.relative(`${path.dirname(filename)}/os.js`, `${path.dirname(filename)}/path.js`)}`)
// path.relative(): ../path.js

// path.join(경로, ...) 여러 인수를 넣으면 하나의 경로로 합친다
// . -> 현재 | .. -> 부모
console.log(`path.join(): ${path.join(__dirname, '..', '..', '/users', '.', '/')}`)
// path.join(): /Users/teng/archive/NodeJS_교과서/users/

// path.resolve(경로, ...) join과 동일하지만 /를 만나면 절대 경로로 인식해서 앞의 경로를 무시함
console.log(`path.resolve(): ${path.resolve(__dirname, '..', 'users', '.', '/')}`)
// /
```

만약, 윈도우에서 POSIX를 쓰거나 그 반대일 경우 `path.posix.sep`, `path.posix.join()`과 `path.win32.sep`, `path.win32.join()`

### url

인터넷 주소를 쉽게 조작하도록 돕는 모듈

- WHATWG 👍
- node 방식

브라우저에서 WHATWG를 사용해서 호환성이 좋음

```jsx
const url = require('url')

const { URL } = url // 노드에서도 제공해서 생략 가능

const myURL = new URL('http://www.gilbut.co.kr/book/bookList.aspx?sercate1=01001000#anchor')
console.log('new URL', myURL)
/*
new URL URL {
  href: 'http://www.gilbut.co.kr/book/bookList.aspx?sercate1=01001000#anchor',
  origin: 'http://www.gilbut.co.kr',
  protocol: 'http:',
  username: '',
  password: '',
  host: 'www.gilbut.co.kr',
  hostname: 'www.gilbut.co.kr',
  port: '',
  pathname: '/book/bookList.aspx',
  search: '?sercate1=01001000',
  searchParams: URLSearchParams { 'sercate1' => '01001000' },
  hash: '#anchor'
}
*/

// 분해되었던 url 객체를 다시 조립
console.log('url.format()', url.format(myURL))
// url.format() http://www.gilbut.co.kr/book/bookList.aspx?sercate1=01001000#anchor
```

node 내장 객체 URLSearchParams에 대해 알아보자

```jsx
const url = new URL('http://naver.com/?page=3&page=4&limit=10')
const searchParams = url.searchParams

console.log(searchParams)
// URLSearchParams { 'page' => '3', 'page' => '4', 'limit' => '10' }

console.log('getAll', searchParams.getAll('page')) // ['3', '4']

console.log('get', searchParams.get('page')) // 3
console.log('get', searchParams.get('limit')) // 10

console.log('has', searchParams.has('page')) // true
console.log('has', searchParams.has('a')) // false

console.log(searchParams.keys()) // Iterator { 'page', 'page', 'limit' }
console.log(searchParams.values()) // Iterator { '3', '4', '10' }

searchParams.append('filter', 'node')
console.log(searchParams.get('filter')) // node

searchParams.set('filter', 'a')
console.log(searchParams.getAll('filter')) // [ 'a' ]

searchParams.delete('filter')
console.log(searchParams.has('filter')) // false

console.log(searchParams.toString()) // page=3&page=4&limit=10

```

### dns

DNS를 다룰 때 사용하는 모듈로 도메인을 통해 IP나 기타 DNS 정보를 얻고자 할 때 사용

```jsx
import dns from 'dns/promises'

// IP를 얻는 방법
const ip = await dns.lookup('gilbut.co.kr')
console.log('IP', ip)
const a = await dns.resolve('gilbut.co.kr', 'A')
console.log('A', a)

const mx = await dns.resolve('gilbut.co.kr', 'MX')
console.log('MX', mx)
const cname = await dns.resolve('www.gilbut.co.kr', 'CNAME')
console.log('CNAME', cname)
const any = await dns.resolve('gilbut.co.kr', 'ANY')
console.log('ANY', any)

// resolve 함수에 두번째 인자를 통해 레코드로 조회할 수 있다.
// - A IPv4
// - AAAA IPv6
// - NS name server
// - SOA 도메인 정보
// - CNAME 별칭
// - MX 메일 서버
```

```jsx
IP { address: '49.236.151.220', family: 4 }
A [ '49.236.151.220' ]
MX [
  { exchange: 'aspmx.l.google.com', priority: 1 },
  { exchange: 'aspmx3.googlemail.com', priority: 10 },
  { exchange: 'alt1.aspmx.l.google.com', priority: 5 },
  { exchange: 'alt2.aspmx.l.google.com', priority: 5 },
  { exchange: 'aspmx2.googlemail.com', priority: 10 }
]
CNAME [ 'slb-1088813.ncloudslb.com' ]
ANY [
  { value: 'ns1-2.ns-ncloud.com', type: 'NS' },
  { value: 'ns1-1.ns-ncloud.com', type: 'NS' },
  {
    nsname: 'ns1-1.ns-ncloud.com',
    hostmaster: 'ns1-2.ns-ncloud.com',
    serial: 132,
    refresh: 21600,
    retry: 1800,
    expire: 1209600,
    minttl: 300,
    type: 'SOA'
  }
]
```

### crypto

다양한 방식의 암호화를 돕는 모듈

<aside>
🤔

만약 비밀번호를 데이터베이스에 저장해야 한다면, 그냥 비밀번호 자체를 넣으면 안 된다.

따라서, 암호화를 하는 것이 중요하다.

</aside>

암호화 방식에는 크게 두 가지가 있다.

- 단방향 암호화
    - 복호화할 수 없는 암호화 방식
- 양방향 암호화
    - 복호화할 수 있는 암호화 방식
    - 대칭

### 단방향 암호화

비밀번호와 같이 원래 문자열을 알 필요없는 경우에는 단방향 암호화를 하는 것이 중요하다.

이러한 암호화를 `해시 함수`라고 부르기도 한다.

→ 로그인 시에는 받은 데이터를 암호화해서 암호화된 문자열과 비교하면 된다.

hash.js

```jsx
const crypto = require('crypto')

console.log('base64: ', crypto.createHash('sha512').update('비밀번호').digest('base64'))
// base64:  dvfV6nyLRRt3NxKSlTHOkkEGgqW2HRtfu19Ou/psUXvwlebbXCboxIPmDYOFRIpqav2eUTBFuHaZri5x+usy1g==
```

createHash

- 사용할 해시 알고리즘을 넣는다 sha512만 해도 충분하다. 필요하다면 더 강한 알고리즘으로 바꾸면 된다.

update

- 변환할 문자열 (여기서는 비밀번호가 된다.)

digest

- 인코딩 알고리즘을 넣는다.
- base64가 짧아서 많이 사용된다.

암호화 알고리즘에 대해 간단하게 더 알아보자.

노드에서는 pbkdf2, bcrypt, scrypt 등 알고리즘이 존재한다.

pbkdf2에 대해 간단히 알아보자.

pbkdf2

- 기존 문자열에 salt를 붙이고 해시 알고리즘을 반복해서 적용하는 것

```jsx
const crypto = require('crypto')

crypto.randomBytes(64, (err, buf) => {
  const salt = buf.toString('base64')
  console.log('salt', salt)

  crypto.pbkdf2('비밀번호', salt, 100000, 64, 'sha512', (err, key) => {
    console.log('password', key.toString('base64'))
  })
})
```

pbkdf2

- 첫번째 인자
    - 암호화할 문자열
- 두번째 인자
    - salt
    - random으로 나오기 때문에 암호화하고 salt를 잘 보관하고 있어야 함
- 세번째 인자
    - 반복 횟수 10만번 반복하는건데 어짜피 컴퓨터로는 1초정도밖에 안 걸림
    - 추가적으로 내부적으로 스레드 풀을 사용해 멀티 스레딩으로 동작함 (블로킹 X)
- 네번째 인자
    - 64byte의 문자열
- 다섯번째 인자
    - 암호화 알고리즘 (hash function)
- 여섯번째 인자
    - callback function

### 양방향 암호화

양방향 대칭형 암호화 → 암호화된 문자열을 복호화할 수 있으며, `키`가 사용됨.

### 더 나아가

- crypto 모듈에 대해 공식문서를 살펴보는 것이 좋다
- npm crypto-js 라이브러리가 있으니 확인해보면 좋다.

### utils

각종 편의 기능을 모아둔 모듈

계속 API가 생기고 있고, `deprecated`되는 경우도 있다.

```jsx
const util = require('util');

const dontUseFunc = util.deprecate((x, y) => {
  console.log(x + y)
}, 'dontUseFunc 함수는 deprecated되었으니 더 이상 사용하지 마세요!')
dontUseFunc(1, 2)
// 3
// (node:50503) DeprecationWarning: dontUseFunc 함수는 deprecated되었으니 더 이상 사용하지 마세요!
// (Use `node --trace-deprecation ...` to show where the warning was created)

const callbackFunc = (x, y, callback) => {
  try {
    const result = x + y // 계산 수행
    callback(null, result) // 첫 번째 인자는 에러(null), 두 번째는 결과
  } catch (error) {
    callback(error) // 에러 발생 시 에러를 전달
  }
}

const promiseFunc = util.promisify(callbackFunc)

;(async () => {
  try {
    const result = await promiseFunc(1, 2);
    console.log(result) // 3
  } catch (error) {
    console.error(error);
  }
})()
```

### worker_threads

노드에서 멀티 스레드 방식으로 작업할 수 있다.

`thread`

```jsx
const {
  Worker,
  isMainThread,
  parentPort
} = require('worker_threads')

if (isMainThread) { // 메인 스레드일 때
  const worker = new Worker(__filename)
  worker.on('message', message => console.log('from worker', message))
  worker.on('exit', () => console.log('worker exit'))
  worker.postMessage('ping')
} else { // 워커일 때
  parentPort.on('message', (value) => {
    console.log('from parent', value)
    parentPort.postMessage('pong')
    parentPort.close()
  })
}
```

`workerData`

```jsx
const {
  Worker,
  isMainThread,
  parentPort,
  workerData
} = require('worker_threads')

if (isMainThread) { // main thread
  const threads = new Set() // Set 자료구조를 통해서 thread를 관리
  for (let i = 0; i < 3; ++i) {
    threads.add(new Worker(__filename, {
      workerData: { start: i }
    }))
  }

  for (const worker of threads) {
    worker.on('message', message => console.log(message))
    worker.on('exit', () => {
      threads.delete(worker)
      
      if (threads.size === 0) {
        console.log('job done')
      }
    })
  }
} else { // worker
  const data = workerData // worker의 데이터 가져오기
  parentPort.postMessage(data.start + 100)
  // 종료되면 main thread의 worker.on('exit', callback)이 실행
}
```

소수 구하기

```jsx
const min = 2
const max = 10000000
const primes = []

function findPrimes(start, end) {
  let isPrime = true
  for (let i = start; i <= end; ++i) {
    for (let j = min; j < Math.sqrt(end); ++j) {
      if (i !== j && i % j === 0) {
        isPrime = false
        break
      }
    }

    if (isPrime) {
      primes.push(i)
    }
    isPrime = true
  }
}

console.time('prime')
findPrimes(min, max)
console.timeEnd('prime') // prime: 5.229s
console.log(primes.length) // 664579
```

이러한 오랜 시간이 걸리는 작업을 워커 스레드를 사용해 문제를 나눠서 푼다.

```jsx
// prime: 953.716ms
// 664579
const {
  Worker, 
  isMainThread,
  parentPort,
  workerData
} = require('worker_threads')

const min = 2
let primes = []

function findPrimes(start, end) {
  let isPrime = true
  for (let i = start; i <= end; ++i) {
    for (let j = min; j < Math.sqrt(end); ++j) {
      if (i !== j && i % j === 0) {
        isPrime = false
        break
      }
    }

    if (isPrime) {
      primes.push(i)
    }
    isPrime = true
  }
}

if (isMainThread) {
  const max = 10000000
  const threadCount = 8
  const threads = new Set()
  const range = Math.floor((max - min) / threadCount)

  let start = min
  console.time('prime')
  for (let i = 0; i < threadCount - 1; ++i) {
    const end = start + range - 1
    threads.add(new Worker(__filename, {
      workerData: { start, range: end }
    }))
    start += range
  }
  threads.add(new Worker(__filename, {
    workerData: { start, range: max }
  }))

  for (const worker of threads) {
    worker.on('error', (err) => {
      throw err
    })

    worker.on('exit', () => {
      threads.delete(worker)
      if (threads.size === 0) {
        console.timeEnd('prime')
        console.log(primes.length)
      }
    })

    worker.on('message', (message) => {
      primes = primes.concat(message)
    })
  }
} else {
  findPrimes(workerData.start, workerData.range)
  parentPort.postMessage(primes)
}
```

### child_process

노드에서 다른 프로그램을 실행하고 싶거나 명령어를 수행하고 싶을 때 사용하는 모듈

이 모듈을 사용하면 다른 언어의 코드 (python, …)를 실행하고 결괏값을 받을 수 있음.

현재 노드 프로세스 외의 새로운 프로세스를 띄워서 명령을 수행하고 노드 프로세스에 결과를 알려주기 때문에 child_process라는 이름을 붙였다.

```
const exec = require('child_process').exec
const process = exec('ls')

process.stdout.on('data', (data) => {
  console.log(data.toString())
  // ls 명령어를 입력했을 때의 결과값을 출력한다.
})

process.stderr.on('data', (data) => {
  console.error(data.toString())
})
```

```jsx
const spawn = require('child_process').spawn
const process = spawn('python', [`${__dirname}/hello.py`])

process.stdout.on('data', (data) => {
  console.log(data.toString())
})

process.stderr.on('data', (data) => {
  console.log(data.toString())
})
```

### 기타 모듈

> 관련해서 직접 예제 코드 만들어보면서 공부해보면 좋을거 같음
> 

- async_hooks
    - 비동기 코드의 흐름을 추적할 수 있는 실험적인 모듈
- dgram
    - UDP와 관련된 작업을 할 때 사용
- net
    - HTTP보다 로우 레벨인 TCP / IPC 통신할 때 사용
- perf_hooks
    - 성능 측정을 할 때 console.time보다 더 정교하게 측정
- querystring
    - URLSearchParams가 나오기 이전에 쿼리스트링을 다루기 위해 사용했던 모듈
- string_decoder
    - 버퍼 데이터를 문자열로 바꾸는 데 사용
- tls
    - TLS / SSL에 관련된 작업을 할 때 사용
- tty
    - 터미널과 관련된 작업을 할 때 사용
- v8
    - v8 엔진에 직접 접근할 때 사용
- vm
    - 가상 머신에 직접 접근할 때 사용
- wasi
    - 웹어셈블리를 실행할 때 사용

## 느낀점

- NodeJS를 통해 많은 것들을 할 수 있는 것을 느꼈고, 재밌게 읽었다.
- 암호학은 끝이 없을거 같아서 간단히 살펴봤다.
- Node에서 제공하는 다양한 API에 대해서는 나중에 천천히 공식문서 읽어보면 좋을거 같다.
- ES module이랑 CommonJS module는 딥다이브에서 소개해서 간단하게 알고 있었는데 좀 더 깊게 알게 된 계기가 되었다.
- thread와 process의 차이점에 더 알게 됐다.
- ai는 python으로 개발하고, spawn 써서 node로 ai 모델 서빙하는 것도 개발할 수 있을거 같다.
    - GPT 말로는 많이 사용하는 패턴이라고 한다.